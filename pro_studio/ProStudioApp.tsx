// Fix: Restored correct import statement and removed mangled code snippet from the file header
import React, { useState, useEffect, useRef } from 'react';
import JSZip from 'jszip';

import Header from '../app1/components/Header';
import ImageConfig from '../app1/components/ImageConfig';
import PromptInput from '../app1/components/PromptInput';
import ImageGallery from '../app1/components/ImageGallery';
import AssetManager from '../app1/components/AssetManager';
import MainMaterialUpload from '../app1/components/MainMaterialUpload';
import { AspectRatio, ImageSize, GeneratedImage, GenerationConfig, SubjectType, PoseCategory, ShootingAngle, ExtendedConfigState, LightingType } from '../app1/types';
import { createGenerationTask, checkTaskStatus } from '../app1/aimgService';
import { getCameraDescription } from '../app1/utils/cameraUtils';
import { getPoseDescription } from '../app1/utils/poseUtils';
import { getLightingDescription } from '../app1/utils/lightingUtils';
import { getExpressionDescription } from '../app1/utils/expressionUtils';
import { getBodyDescription } from '../app1/utils/bodyUtils';

const ProStudioApp: React.FC = () => {
  const [promptsText, setPromptsText] = useState('');
  const [config, setConfig] = useState<GenerationConfig>({
    aspectRatio: AspectRatio.SQUARE,
    imageSize: ImageSize.K1,
    model: 'nano-banana-pro'
  });

  const [extendedConfig, setExtendedConfig] = useState<ExtendedConfigState>({
    subjectType: SubjectType.PERSON,
    poseCategory: PoseCategory.FULL_BODY,
    selectedPoseId: null,
    shootingAngle: ShootingAngle.EYE_LEVEL,
    use3DControl: true,
    editorMode: 'camera',
    camera: { 
      azimuth: 0, 
      elevation: 0, 
      distance: 1.0
    },
    cameraEnabled: false, // 默认禁用
    skeleton: {
        hips: { rotation: [0, 0, 0] },
        spine: { rotation: [0, 0, 0] },
        chest: { rotation: [0, 0, 0] },
        neck: { rotation: [0, 0, 0] },
        leftShoulder: { rotation: [0, 0, 0] },
        rightShoulder: { rotation: [0, 0, 0] },
        leftHip: { rotation: [0, 0, 0] },
        rightHip: { rotation: [0, 0, 0] }
    },
    poseEnabled: false, // 默认禁用
    lighting: {
        azimuth: 45,
        elevation: 45,
        intensity: 1.0,
        color: "#ffffff",
        type: LightingType.DEFAULT
    },
    lightingEnabled: false, // 默认禁用
    expression: {
        presetId: 'neutral',
        happiness: 0,
        anger: 0,
        surprise: 0,
        mouthOpen: 0,
        gazeX: 0,
        gazeY: 0
    },
    expressionEnabled: false, // 默认禁用
    bodyShape: {
        build: 0,
        shoulderWidth: 0,
        bustSize: 0.2, 
        waistWidth: 0,
        hipWidth: 0,
        legLength: 0
    },
    bodyEnabled: false, // 默认禁用
    assets: { 
        faceImage: null,
        clothingImage: null,
        backgroundImage: null
    }
  });

  const [clothingAnalysis, setClothingAnalysis] = useState('');
  const [referenceImages, setReferenceImages] = useState<string[]>([]);
  const [results, setResults] = useState<GeneratedImage[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isBatchDownloading, setIsBatchDownloading] = useState(false);
  
  const pollIntervals = useRef<{ [key: string]: number }>({});

  useEffect(() => {
    return () => {
      Object.values(pollIntervals.current).forEach(window.clearInterval);
    };
  }, []);

  const handleExtendedConfigChange = (updates: Partial<ExtendedConfigState>) => {
    setExtendedConfig(prev => {
        const next = { ...prev, ...updates };
        
        // 优化提示词自动补全逻辑：仅在用户显式开启某个开关时，才按需添加对应的占位符
        if (updates.cameraEnabled === true || updates.poseEnabled === true || updates.lightingEnabled === true || updates.expressionEnabled === true || updates.bodyEnabled === true) {
            setPromptsText(prevText => {
                let newText = prevText;
                const useBg = !!(updates.assets?.backgroundImage || prev.assets.backgroundImage);

                if (updates.poseEnabled === true && !newText.includes("[selected_pose]")) {
                    newText = newText.trim() ? `${newText}, [selected_pose]` : "[selected_pose]";
                }
                if (updates.expressionEnabled === true && !newText.includes("[expression]")) {
                    newText = newText.trim() ? `${newText}, [expression]` : "[expression]";
                }
                if (updates.bodyEnabled === true && !newText.includes("[body_shape]")) {
                    newText = newText.trim() ? `${newText}, [body_shape]` : "[body_shape]";
                }
                if (updates.cameraEnabled === true && !newText.includes("[selected_angle]")) {
                    newText = newText.trim() ? `${newText}, [selected_angle]` : "[selected_angle]";
                }
                if (updates.lightingEnabled === true && !newText.includes("[lighting]") && !useBg) {
                    newText = newText.trim() ? `${newText}, [lighting]` : "[lighting]";
                }
                
                return newText;
            });
        }
        return next;
    });
  };

  const constructEnhancedPrompt = (basePrompt: string): string => {
    let enhancedPrompt = basePrompt.trim();
    
    // 逻辑开关：只有在对应的功能启用时，才生成描述词；否则输出空值
    const poseKeywords = extendedConfig.poseEnabled ? getPoseDescription(extendedConfig.skeleton) : "";
    const angleKeywords = extendedConfig.cameraEnabled ? getCameraDescription(extendedConfig.camera) : "";
    
    const isLongShot = extendedConfig.cameraEnabled && extendedConfig.camera.distance > 1.6;
    const isExtremeTopView = extendedConfig.cameraEnabled && extendedConfig.camera.elevation > 82;
    const isExtremeBottomView = extendedConfig.cameraEnabled && extendedConfig.camera.elevation < -82;

    let lightingKeywords = extendedConfig.lightingEnabled ? getLightingDescription(extendedConfig.lighting) : "";
    if (extendedConfig.assets.backgroundImage) {
        lightingKeywords = lightingKeywords.replace(/clean background|studio|sunlight|night scene/gi, "").trim();
    }

    const expressionKeywords = extendedConfig.expressionEnabled ? getExpressionDescription(extendedConfig.expression) : "";
    const bodyKeywords = extendedConfig.bodyEnabled ? getBodyDescription(extendedConfig.bodyShape) : "";

    if (referenceImages.length > 0) {
        if (isLongShot || isExtremeTopView) {
            enhancedPrompt += ", ignore the main reference person scale, make the person much smaller, change perspective completely";
        } else {
            enhancedPrompt += ",  ";
        }
    }

    if (extendedConfig.assets.faceImage) {
        enhancedPrompt += ", swap face with the provided face reference";
    }
    if (extendedConfig.assets.clothingImage) {
        enhancedPrompt += ",A high-fidelity photograph based on the structure of [Image_1_Model_Base]. 1. BASE MODEL RETENTION: Retain the exact subject identity (gender unspecified), pose, body shape, framing (crop or full-body), and background environment as depicted in [Image_1_Model_Base]. Any body parts or clothing areas not covered by the new target garment must remain completely unchanged. 2. TARGET GARMENT APPLICATION: The subject is now wearing the main garment visualized in [Image_2_Main_Garment]. This new garment replaces the original clothing in the corresponding anatomical area, draping naturally according to the subject's pose in [Image_1_Model_Base]. 3. MANDATORY DETAIL ENFORCEMENT (CRITICAL): The rendered garment on the model must be a precise reconstruction incorporating the specific micro-details from the reference images. The AI is not allowed to hallucinate details; it must strictly use the provided references: * Apply the exact fabric texture, pattern, material quality, and stitching style visible in [Image_3_Detail_Ref]. * Incorporate specific functional elements, hardware (zippers, buttons, pulls), or closure mechanisms precisely as detailed in [Image_4_Detail_Ref]. * Replicate fine structural details, such as cuff construction, hem finishing, lining, or layering elements, exactly as presented in [Image_5_Detail_Ref]. FINAL SYNTHESIS: The final output must be a realistic integration of the garment defined by [Image_2] and its details [Image_3-5] onto the base subject of [Image_1], with consistent lighting and realistic fabric physics.";
        if (clothingAnalysis) {
          enhancedPrompt += `, (garment structural details: ${clothingAnalysis}:1.4)`;
        }
    }
    if (extendedConfig.assets.backgroundImage) {
        enhancedPrompt += ", replace background with the provided background reference";
    }

    if (extendedConfig.cameraEnabled && extendedConfig.camera.distance > 2.5) {
        enhancedPrompt = `(A vast expansive scenery:1.3), ${enhancedPrompt}`;
    }
    
    if (isExtremeTopView) {
        enhancedPrompt = `(Extreme overhead perspective:1.4), (nadir shot of ground:1.3), flat lay composition, ${enhancedPrompt.replace(/portrait|looking at camera/gi, "looking down")}`;
    }

    // 替换占位符，若功能关闭则会替换为空字符串
    enhancedPrompt = enhancedPrompt
        .replace(/\[(selected_)?pose\]/g, poseKeywords)
        .replace(/\[(selected_)?angle\]/g, angleKeywords)
        .replace(/\[(selected_)?lighting\]/g, lightingKeywords)
        .replace(/\[(selected_)?expression\]/g, expressionKeywords)
        .replace(/\[(selected_)?body_shape\]/g, bodyKeywords);
    
    if (!enhancedPrompt.toLowerCase().includes('professional photography')) {
        enhancedPrompt += ", ";
    }

    if (isLongShot) {
        enhancedPrompt += ", small person scale, miniature figure, cinematic landscape focus";
    }
    if (isExtremeBottomView) {
        enhancedPrompt += ", (zenith perspective:1.5), hero shot from very low ground, giant scale";
    }
    
    // 鲁棒清理逻辑：去除多余逗号、空格以及末尾的标点
    return enhancedPrompt
        .replace(/,+/g, ',')
        .replace(/,\s*,/g, ',')
        .replace(/\s\s+/g, ' ')
        .replace(/,\s*$/g, '')
        .trim();
  };

  const startGeneration = async () => {
    const rawPrompts = promptsText.split('\n').map(p => p.trim()).filter(p => p.length > 0);
    if (rawPrompts.length === 0) return;
    setIsGenerating(true);
    
    const newItems: GeneratedImage[] = rawPrompts.map((p, idx) => ({
      id: `${Date.now()}-${idx}`,
      prompt: constructEnhancedPrompt(p),
      url: null,
      progress: 0,
      status: 'pending'
    }));
    
    setResults(prev => [...newItems, ...prev]);

    const finalReferenceImages: string[] = [];
    if (referenceImages.length > 0) finalReferenceImages.push(referenceImages[0]);
    if (extendedConfig.assets.faceImage) finalReferenceImages.push(extendedConfig.assets.faceImage);
    if (extendedConfig.assets.clothingImage) finalReferenceImages.push(extendedConfig.assets.clothingImage);
    if (extendedConfig.assets.backgroundImage) finalReferenceImages.push(extendedConfig.assets.backgroundImage);

    const payloadImages = finalReferenceImages.slice(0, 5);

    for (const item of newItems) {
      try {
        const taskId = await createGenerationTask(item.prompt, config, payloadImages);
        updateResult(item.id, { taskId, status: 'running', progress: 5 });
        startPolling(item.id, taskId);
      } catch (error: any) {
        updateResult(item.id, { status: 'error', error: error.message || '提交任务失败' });
      }
    }
    setIsGenerating(false);
  };

  const startPolling = (localId: string, taskId: string) => {
    if (pollIntervals.current[localId]) window.clearInterval(pollIntervals.current[localId]);

    const intervalId = window.setInterval(async () => {
      try {
        const data = await checkTaskStatus(taskId);
        if (data.status === 'succeeded' && data.results?.[0]?.url) {
          updateResult(localId, { url: data.results[0].url, status: 'succeeded', progress: 100 });
          stopPolling(localId);
        } else if (data.status === 'failed' || data.status === 'error') {
          updateResult(localId, { 
            status: 'failed', 
            failureReason: data.failure_reason, 
            error: data.error || data.failure_reason || "API 内部处理失败" 
          });
          stopPolling(localId);
        } else {
          updateResult(localId, { progress: data.progress || 10, status: 'running' });
        }
      } catch (err: any) {
        updateResult(localId, { status: 'error', error: err.message });
        stopPolling(localId);
      }
    }, 2000);

    pollIntervals.current[localId] = intervalId;
  };

  const stopPolling = (localId: string) => {
    if (pollIntervals.current[localId]) {
      window.clearInterval(pollIntervals.current[localId]);
      delete pollIntervals.current[localId];
    }
  };

  const updateResult = (id: string, updates: Partial<GeneratedImage>) => {
    setResults(prev => prev.map(item => item.id === id ? { ...item, ...updates } : item));
  };

  const sanitizeFilename = (text: string) => {
    return text.trim()
      .replace(/[\\/:\*\?"<>\|]/g, '-')
      .replace(/\s+/g, '-')
      .slice(0, 50);
  };

  const handleBatchDownload = async () => {
    const successfulItems = results.filter(item => item.status === 'succeeded' && item.url);
    if (successfulItems.length === 0) return;

    setIsBatchDownloading(true);
    try {
      const zip = new JSZip();
      const downloadPromises = successfulItems.map(async (item) => {
        try {
          const response = await fetch(item.url!, { mode: 'cors' });
          if (!response.ok) throw new Error(`HTTP Error ${response.status}`);
          const blob = await response.blob();
          const safeBaseName = sanitizeFilename(item.prompt) || '智拍成品';
          const fileName = `${safeBaseName}-${item.id.slice(-4)}.png`;
          zip.file(fileName, blob);
        } catch (e) {
          console.error(`下载图片失败: ${item.url}`, e);
        }
      });

      await Promise.all(downloadPromises);
      const content = await zip.generateAsync({ type: 'blob' });
      const blobUrl = window.URL.createObjectURL(content);
      const link = document.createElement('a');
      link.href = blobUrl;
      link.download = `智拍大师-批量导出-${new Date().getTime()}.zip`;
      link.click();
      window.URL.revokeObjectURL(blobUrl);
    } catch (error: any) {
      alert(`打包失败: ${error.message}`);
    } finally {
      setIsBatchDownloading(false);
    }
  };

  const successfulCount = results.filter(i => i.status === 'succeeded').length;

  return (
    <div className="min-h-screen flex flex-col bg-slate-50">
      <Header />
      <main className="flex-1 max-w-7xl mx-auto w-full px-4 py-8 flex flex-col md:flex-row gap-8">
        <aside className="w-full md:w-[420px] space-y-6">
          <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 space-y-6">
            <MainMaterialUpload referenceImages={referenceImages} onChange={setReferenceImages} />
            <AssetManager 
                assets={extendedConfig.assets} 
                onChange={(a) => handleExtendedConfigChange({ assets: a })} 
                clothingAnalysis={clothingAnalysis}
                onAnalysisChange={setClothingAnalysis}
            />
            <div className="border-t border-slate-100"></div>
            <h2 className="text-lg font-bold flex items-center gap-2 text-slate-900">
               <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4" /></svg>
               3D 参数与环境配置
            </h2>
            <ImageConfig 
                config={config} 
                onConfigChange={setConfig} 
                extendedConfig={extendedConfig} 
                onExtendedConfigChange={handleExtendedConfigChange} 
                previewImage={referenceImages[0]} 
            />
            <div className="mt-6">
              <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">批量提示词</label>
              <PromptInput value={promptsText} onChange={setPromptsText} isGenerating={isGenerating} onGenerate={startGeneration} />
            </div>
            <button onClick={startGeneration} disabled={isGenerating || !promptsText.trim()} className="w-full mt-6 py-4 bg-blue-600 text-white rounded-xl font-bold shadow-lg hover:scale-[1.02] transition-transform active:scale-95 disabled:opacity-50">
              {isGenerating ? '正在提交任务...' : '开始批量出图'}
            </button>
          </div>
        </aside>
        <section className="flex-1">
          <div className="mb-6 flex items-center justify-between">
            <div>
               <h2 className="text-2xl font-bold text-slate-800">生成画廊</h2>
               <p className="text-sm text-slate-500">智拍大师实时反馈生成进度</p>
            </div>
            <div className="flex items-center gap-3">
              {successfulCount > 0 && (
                <button 
                  onClick={handleBatchDownload}
                  disabled={isBatchDownloading}
                  className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-sm ${
                    isBatchDownloading 
                    ? 'bg-slate-100 text-slate-400 cursor-wait' 
                    : 'bg-white text-blue-600 border border-blue-100 hover:bg-blue-50 hover:shadow-md'
                  }`}
                >
                  {isBatchDownloading ? '正在打包...' : `一键批量下载 (${successfulCount})`}
                </button>
              )}
              {results.length > 0 && (
                <button onClick={() => setResults([])} className="px-4 py-2 text-sm font-medium text-slate-400 hover:text-red-500 transition-colors bg-white rounded-lg border border-slate-100">
                  清空列表
                </button>
              )}
            </div>
          </div>
          {results.length === 0 ? (
            <div className="bg-white border-2 border-dashed border-slate-200 rounded-3xl h-[600px] flex flex-col items-center justify-center text-slate-400 shadow-sm text-center px-4">
              <p className="text-lg font-semibold text-slate-600">欢迎使用智拍大师 Pro</p>
              <p className="text-sm text-slate-400 mt-1">上传参考素材并配置 3D 参数，即可开始批量创作</p>
            </div>
          ) : (
            <ImageGallery items={results} onRetry={(item) => {
                const basePrompt = promptsText.split('\n')[0] || item.prompt;
                setPromptsText(basePrompt);
                startGeneration();
            }} />
          )}
        </section>
      </main>
    </div>
  );
};

export default ProStudioApp;